// Code generated by Prisma (prisma@1.26.4). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from 'graphql';
import { makePrismaClientClass, BaseClientOptions, Model } from 'prisma-client-lib';
import { typeDefs } from './prisma-schema';

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> & U[keyof U];

export interface Exists {
  department: (where?: DepartmentWhereInput) => Promise<boolean>;
  school: (where?: SchoolWhereInput) => Promise<boolean>;
  term: (where?: TermWhereInput) => Promise<boolean>;
  venue: (where?: VenueWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(query: string, variables?: { [key: string]: any }) => Promise<T>;

  /**
   * Queries
   */

  department: (where: DepartmentWhereUniqueInput) => DepartmentPromise;
  departments: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Department>;
  departmentsConnection: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DepartmentConnectionPromise;
  school: (where: SchoolWhereUniqueInput) => SchoolPromise;
  schools: (args?: {
    where?: SchoolWhereInput;
    orderBy?: SchoolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<School>;
  schoolsConnection: (args?: {
    where?: SchoolWhereInput;
    orderBy?: SchoolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SchoolConnectionPromise;
  term: (where: TermWhereUniqueInput) => TermPromise;
  terms: (args?: {
    where?: TermWhereInput;
    orderBy?: TermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Term>;
  termsConnection: (args?: {
    where?: TermWhereInput;
    orderBy?: TermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TermConnectionPromise;
  venue: (where: VenueWhereUniqueInput) => VenuePromise;
  venues: (args?: {
    where?: VenueWhereInput;
    orderBy?: VenueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Venue>;
  venuesConnection: (args?: {
    where?: VenueWhereInput;
    orderBy?: VenueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VenueConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createDepartment: (data: DepartmentCreateInput) => DepartmentPromise;
  updateDepartment: (args: {
    data: DepartmentUpdateInput;
    where: DepartmentWhereUniqueInput;
  }) => DepartmentPromise;
  updateManyDepartments: (args: {
    data: DepartmentUpdateManyMutationInput;
    where?: DepartmentWhereInput;
  }) => BatchPayloadPromise;
  upsertDepartment: (args: {
    where: DepartmentWhereUniqueInput;
    create: DepartmentCreateInput;
    update: DepartmentUpdateInput;
  }) => DepartmentPromise;
  deleteDepartment: (where: DepartmentWhereUniqueInput) => DepartmentPromise;
  deleteManyDepartments: (where?: DepartmentWhereInput) => BatchPayloadPromise;
  createSchool: (data: SchoolCreateInput) => SchoolPromise;
  updateSchool: (args: { data: SchoolUpdateInput; where: SchoolWhereUniqueInput }) => SchoolPromise;
  updateManySchools: (args: {
    data: SchoolUpdateManyMutationInput;
    where?: SchoolWhereInput;
  }) => BatchPayloadPromise;
  upsertSchool: (args: {
    where: SchoolWhereUniqueInput;
    create: SchoolCreateInput;
    update: SchoolUpdateInput;
  }) => SchoolPromise;
  deleteSchool: (where: SchoolWhereUniqueInput) => SchoolPromise;
  deleteManySchools: (where?: SchoolWhereInput) => BatchPayloadPromise;
  createTerm: (data: TermCreateInput) => TermPromise;
  updateTerm: (args: { data: TermUpdateInput; where: TermWhereUniqueInput }) => TermPromise;
  updateManyTerms: (args: {
    data: TermUpdateManyMutationInput;
    where?: TermWhereInput;
  }) => BatchPayloadPromise;
  upsertTerm: (args: {
    where: TermWhereUniqueInput;
    create: TermCreateInput;
    update: TermUpdateInput;
  }) => TermPromise;
  deleteTerm: (where: TermWhereUniqueInput) => TermPromise;
  deleteManyTerms: (where?: TermWhereInput) => BatchPayloadPromise;
  createVenue: (data: VenueCreateInput) => VenuePromise;
  updateVenue: (args: { data: VenueUpdateInput; where: VenueWhereUniqueInput }) => VenuePromise;
  updateManyVenues: (args: {
    data: VenueUpdateManyMutationInput;
    where?: VenueWhereInput;
  }) => BatchPayloadPromise;
  upsertVenue: (args: {
    where: VenueWhereUniqueInput;
    create: VenueCreateInput;
    update: VenueUpdateInput;
  }) => VenuePromise;
  deleteVenue: (where: VenueWhereUniqueInput) => VenuePromise;
  deleteManyVenues: (where?: VenueWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  department: (
    where?: DepartmentSubscriptionWhereInput,
  ) => DepartmentSubscriptionPayloadSubscription;
  school: (where?: SchoolSubscriptionWhereInput) => SchoolSubscriptionPayloadSubscription;
  term: (where?: TermSubscriptionWhereInput) => TermSubscriptionPayloadSubscription;
  venue: (where?: VenueSubscriptionWhereInput) => VenueSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type TermOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'startsAt_ASC'
  | 'startsAt_DESC'
  | 'endsAt_ASC'
  | 'endsAt_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type VenueOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'code_ASC'
  | 'code_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'floor_ASC'
  | 'floor_DESC'
  | 'lat_ASC'
  | 'lat_DESC'
  | 'lng_ASC'
  | 'lng_DESC'
  | 'altitude_ASC'
  | 'altitude_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type DepartmentOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type SchoolOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'longName_ASC'
  | 'longName_DESC'
  | 'shortName_ASC'
  | 'shortName_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type MutationType = 'CREATED' | 'UPDATED' | 'DELETED';

export interface VenueScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  floor?: String;
  floor_not?: String;
  floor_in?: String[] | String;
  floor_not_in?: String[] | String;
  floor_lt?: String;
  floor_lte?: String;
  floor_gt?: String;
  floor_gte?: String;
  floor_contains?: String;
  floor_not_contains?: String;
  floor_starts_with?: String;
  floor_not_starts_with?: String;
  floor_ends_with?: String;
  floor_not_ends_with?: String;
  lat?: Float;
  lat_not?: Float;
  lat_in?: Float[] | Float;
  lat_not_in?: Float[] | Float;
  lat_lt?: Float;
  lat_lte?: Float;
  lat_gt?: Float;
  lat_gte?: Float;
  lng?: Float;
  lng_not?: Float;
  lng_in?: Float[] | Float;
  lng_not_in?: Float[] | Float;
  lng_lt?: Float;
  lng_lte?: Float;
  lng_gt?: Float;
  lng_gte?: Float;
  altitude?: Int;
  altitude_not?: Int;
  altitude_in?: Int[] | Int;
  altitude_not_in?: Int[] | Int;
  altitude_lt?: Int;
  altitude_lte?: Int;
  altitude_gt?: Int;
  altitude_gte?: Int;
  AND?: VenueScalarWhereInput[] | VenueScalarWhereInput;
  OR?: VenueScalarWhereInput[] | VenueScalarWhereInput;
  NOT?: VenueScalarWhereInput[] | VenueScalarWhereInput;
}

export type DepartmentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TermUpsertWithWhereUniqueWithoutSchoolInput {
  where: TermWhereUniqueInput;
  update: TermUpdateWithoutSchoolDataInput;
  create: TermCreateWithoutSchoolInput;
}

export interface SchoolWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  longName?: String;
  longName_not?: String;
  longName_in?: String[] | String;
  longName_not_in?: String[] | String;
  longName_lt?: String;
  longName_lte?: String;
  longName_gt?: String;
  longName_gte?: String;
  longName_contains?: String;
  longName_not_contains?: String;
  longName_starts_with?: String;
  longName_not_starts_with?: String;
  longName_ends_with?: String;
  longName_not_ends_with?: String;
  shortName?: String;
  shortName_not?: String;
  shortName_in?: String[] | String;
  shortName_not_in?: String[] | String;
  shortName_lt?: String;
  shortName_lte?: String;
  shortName_gt?: String;
  shortName_gte?: String;
  shortName_contains?: String;
  shortName_not_contains?: String;
  shortName_starts_with?: String;
  shortName_not_starts_with?: String;
  shortName_ends_with?: String;
  shortName_not_ends_with?: String;
  terms_every?: TermWhereInput;
  terms_some?: TermWhereInput;
  terms_none?: TermWhereInput;
  departments_every?: DepartmentWhereInput;
  departments_some?: DepartmentWhereInput;
  departments_none?: DepartmentWhereInput;
  AND?: SchoolWhereInput[] | SchoolWhereInput;
  OR?: SchoolWhereInput[] | SchoolWhereInput;
  NOT?: SchoolWhereInput[] | SchoolWhereInput;
}

export interface TermScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  startsAt?: DateTimeInput;
  startsAt_not?: DateTimeInput;
  startsAt_in?: DateTimeInput[] | DateTimeInput;
  startsAt_not_in?: DateTimeInput[] | DateTimeInput;
  startsAt_lt?: DateTimeInput;
  startsAt_lte?: DateTimeInput;
  startsAt_gt?: DateTimeInput;
  startsAt_gte?: DateTimeInput;
  endsAt?: DateTimeInput;
  endsAt_not?: DateTimeInput;
  endsAt_in?: DateTimeInput[] | DateTimeInput;
  endsAt_not_in?: DateTimeInput[] | DateTimeInput;
  endsAt_lt?: DateTimeInput;
  endsAt_lte?: DateTimeInput;
  endsAt_gt?: DateTimeInput;
  endsAt_gte?: DateTimeInput;
  AND?: TermScalarWhereInput[] | TermScalarWhereInput;
  OR?: TermScalarWhereInput[] | TermScalarWhereInput;
  NOT?: TermScalarWhereInput[] | TermScalarWhereInput;
}

export interface VenueWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  floor?: String;
  floor_not?: String;
  floor_in?: String[] | String;
  floor_not_in?: String[] | String;
  floor_lt?: String;
  floor_lte?: String;
  floor_gt?: String;
  floor_gte?: String;
  floor_contains?: String;
  floor_not_contains?: String;
  floor_starts_with?: String;
  floor_not_starts_with?: String;
  floor_ends_with?: String;
  floor_not_ends_with?: String;
  lat?: Float;
  lat_not?: Float;
  lat_in?: Float[] | Float;
  lat_not_in?: Float[] | Float;
  lat_lt?: Float;
  lat_lte?: Float;
  lat_gt?: Float;
  lat_gte?: Float;
  lng?: Float;
  lng_not?: Float;
  lng_in?: Float[] | Float;
  lng_not_in?: Float[] | Float;
  lng_lt?: Float;
  lng_lte?: Float;
  lng_gt?: Float;
  lng_gte?: Float;
  altitude?: Int;
  altitude_not?: Int;
  altitude_in?: Int[] | Int;
  altitude_not_in?: Int[] | Int;
  altitude_lt?: Int;
  altitude_lte?: Int;
  altitude_gt?: Int;
  altitude_gte?: Int;
  terms_every?: TermWhereInput;
  terms_some?: TermWhereInput;
  terms_none?: TermWhereInput;
  AND?: VenueWhereInput[] | VenueWhereInput;
  OR?: VenueWhereInput[] | VenueWhereInput;
  NOT?: VenueWhereInput[] | VenueWhereInput;
}

export interface DepartmentUpdateInput {
  name?: String;
  school?: SchoolUpdateOneRequiredWithoutDepartmentsInput;
}

export interface DepartmentUpdateManyWithWhereNestedInput {
  where: DepartmentScalarWhereInput;
  data: DepartmentUpdateManyDataInput;
}

export interface SchoolUpdateOneRequiredWithoutDepartmentsInput {
  create?: SchoolCreateWithoutDepartmentsInput;
  update?: SchoolUpdateWithoutDepartmentsDataInput;
  upsert?: SchoolUpsertWithoutDepartmentsInput;
  connect?: SchoolWhereUniqueInput;
}

export interface TermUpdateManyWithWhereNestedInput {
  where: TermScalarWhereInput;
  data: TermUpdateManyDataInput;
}

export interface SchoolUpdateWithoutDepartmentsDataInput {
  longName?: String;
  shortName?: String;
  terms?: TermUpdateManyWithoutSchoolInput;
}

export interface TermWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  startsAt?: DateTimeInput;
  startsAt_not?: DateTimeInput;
  startsAt_in?: DateTimeInput[] | DateTimeInput;
  startsAt_not_in?: DateTimeInput[] | DateTimeInput;
  startsAt_lt?: DateTimeInput;
  startsAt_lte?: DateTimeInput;
  startsAt_gt?: DateTimeInput;
  startsAt_gte?: DateTimeInput;
  endsAt?: DateTimeInput;
  endsAt_not?: DateTimeInput;
  endsAt_in?: DateTimeInput[] | DateTimeInput;
  endsAt_not_in?: DateTimeInput[] | DateTimeInput;
  endsAt_lt?: DateTimeInput;
  endsAt_lte?: DateTimeInput;
  endsAt_gt?: DateTimeInput;
  endsAt_gte?: DateTimeInput;
  school?: SchoolWhereInput;
  venues_every?: VenueWhereInput;
  venues_some?: VenueWhereInput;
  venues_none?: VenueWhereInput;
  AND?: TermWhereInput[] | TermWhereInput;
  OR?: TermWhereInput[] | TermWhereInput;
  NOT?: TermWhereInput[] | TermWhereInput;
}

export interface TermUpdateManyWithoutSchoolInput {
  create?: TermCreateWithoutSchoolInput[] | TermCreateWithoutSchoolInput;
  delete?: TermWhereUniqueInput[] | TermWhereUniqueInput;
  connect?: TermWhereUniqueInput[] | TermWhereUniqueInput;
  set?: TermWhereUniqueInput[] | TermWhereUniqueInput;
  disconnect?: TermWhereUniqueInput[] | TermWhereUniqueInput;
  update?:
    | TermUpdateWithWhereUniqueWithoutSchoolInput[]
    | TermUpdateWithWhereUniqueWithoutSchoolInput;
  upsert?:
    | TermUpsertWithWhereUniqueWithoutSchoolInput[]
    | TermUpsertWithWhereUniqueWithoutSchoolInput;
  deleteMany?: TermScalarWhereInput[] | TermScalarWhereInput;
  updateMany?: TermUpdateManyWithWhereNestedInput[] | TermUpdateManyWithWhereNestedInput;
}

export interface SchoolSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SchoolWhereInput;
  AND?: SchoolSubscriptionWhereInput[] | SchoolSubscriptionWhereInput;
  OR?: SchoolSubscriptionWhereInput[] | SchoolSubscriptionWhereInput;
  NOT?: SchoolSubscriptionWhereInput[] | SchoolSubscriptionWhereInput;
}

export interface TermUpdateWithWhereUniqueWithoutSchoolInput {
  where: TermWhereUniqueInput;
  data: TermUpdateWithoutSchoolDataInput;
}

export interface VenueUpdateManyMutationInput {
  code?: String;
  name?: String;
  floor?: String;
  lat?: Float;
  lng?: Float;
  altitude?: Int;
}

export interface TermUpdateWithoutSchoolDataInput {
  name?: String;
  startsAt?: DateTimeInput;
  endsAt?: DateTimeInput;
  venues?: VenueUpdateManyWithoutTermsInput;
}

export interface TermUpdateWithoutVenuesDataInput {
  name?: String;
  startsAt?: DateTimeInput;
  endsAt?: DateTimeInput;
  school?: SchoolUpdateOneRequiredWithoutTermsInput;
}

export interface VenueUpdateManyWithoutTermsInput {
  create?: VenueCreateWithoutTermsInput[] | VenueCreateWithoutTermsInput;
  delete?: VenueWhereUniqueInput[] | VenueWhereUniqueInput;
  connect?: VenueWhereUniqueInput[] | VenueWhereUniqueInput;
  set?: VenueWhereUniqueInput[] | VenueWhereUniqueInput;
  disconnect?: VenueWhereUniqueInput[] | VenueWhereUniqueInput;
  update?:
    | VenueUpdateWithWhereUniqueWithoutTermsInput[]
    | VenueUpdateWithWhereUniqueWithoutTermsInput;
  upsert?:
    | VenueUpsertWithWhereUniqueWithoutTermsInput[]
    | VenueUpsertWithWhereUniqueWithoutTermsInput;
  deleteMany?: VenueScalarWhereInput[] | VenueScalarWhereInput;
  updateMany?: VenueUpdateManyWithWhereNestedInput[] | VenueUpdateManyWithWhereNestedInput;
}

export type SchoolWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  longName?: String;
}>;

export interface VenueUpdateWithWhereUniqueWithoutTermsInput {
  where: VenueWhereUniqueInput;
  data: VenueUpdateWithoutTermsDataInput;
}

export interface VenueUpdateInput {
  code?: String;
  name?: String;
  floor?: String;
  lat?: Float;
  lng?: Float;
  altitude?: Int;
  terms?: TermUpdateManyWithoutVenuesInput;
}

export interface VenueUpdateWithoutTermsDataInput {
  code?: String;
  name?: String;
  floor?: String;
  lat?: Float;
  lng?: Float;
  altitude?: Int;
}

export interface TermCreateManyWithoutVenuesInput {
  create?: TermCreateWithoutVenuesInput[] | TermCreateWithoutVenuesInput;
  connect?: TermWhereUniqueInput[] | TermWhereUniqueInput;
}

export interface VenueUpsertWithWhereUniqueWithoutTermsInput {
  where: VenueWhereUniqueInput;
  update: VenueUpdateWithoutTermsDataInput;
  create: VenueCreateWithoutTermsInput;
}

export interface VenueCreateInput {
  code: String;
  name: String;
  floor?: String;
  lat?: Float;
  lng?: Float;
  altitude?: Int;
  terms?: TermCreateManyWithoutVenuesInput;
}

export interface SchoolCreateWithoutTermsInput {
  longName: String;
  shortName?: String;
  departments?: DepartmentCreateManyWithoutSchoolInput;
}

export interface SchoolUpsertWithoutTermsInput {
  update: SchoolUpdateWithoutTermsDataInput;
  create: SchoolCreateWithoutTermsInput;
}

export interface VenueUpdateManyWithWhereNestedInput {
  where: VenueScalarWhereInput;
  data: VenueUpdateManyDataInput;
}

export interface SchoolUpdateWithoutTermsDataInput {
  longName?: String;
  shortName?: String;
  departments?: DepartmentUpdateManyWithoutSchoolInput;
}

export interface VenueUpdateManyDataInput {
  code?: String;
  name?: String;
  floor?: String;
  lat?: Float;
  lng?: Float;
  altitude?: Int;
}

export interface TermUpdateInput {
  name?: String;
  startsAt?: DateTimeInput;
  endsAt?: DateTimeInput;
  school?: SchoolUpdateOneRequiredWithoutTermsInput;
  venues?: VenueUpdateManyWithoutTermsInput;
}

export interface DepartmentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  school?: SchoolWhereInput;
  AND?: DepartmentWhereInput[] | DepartmentWhereInput;
  OR?: DepartmentWhereInput[] | DepartmentWhereInput;
  NOT?: DepartmentWhereInput[] | DepartmentWhereInput;
}

export interface DepartmentCreateInput {
  name: String;
  school: SchoolCreateOneWithoutDepartmentsInput;
}

export interface SchoolCreateOneWithoutTermsInput {
  create?: SchoolCreateWithoutTermsInput;
  connect?: SchoolWhereUniqueInput;
}

export interface SchoolCreateWithoutDepartmentsInput {
  longName: String;
  shortName?: String;
  terms?: TermCreateManyWithoutSchoolInput;
}

export interface TermCreateInput {
  name: String;
  startsAt: DateTimeInput;
  endsAt: DateTimeInput;
  school: SchoolCreateOneWithoutTermsInput;
  venues?: VenueCreateManyWithoutTermsInput;
}

export interface TermCreateWithoutSchoolInput {
  name: String;
  startsAt: DateTimeInput;
  endsAt: DateTimeInput;
  venues?: VenueCreateManyWithoutTermsInput;
}

export interface TermUpdateManyDataInput {
  name?: String;
  startsAt?: DateTimeInput;
  endsAt?: DateTimeInput;
}

export interface VenueCreateWithoutTermsInput {
  code: String;
  name: String;
  floor?: String;
  lat?: Float;
  lng?: Float;
  altitude?: Int;
}

export interface SchoolUpsertWithoutDepartmentsInput {
  update: SchoolUpdateWithoutDepartmentsDataInput;
  create: SchoolCreateWithoutDepartmentsInput;
}

export interface TermSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TermWhereInput;
  AND?: TermSubscriptionWhereInput[] | TermSubscriptionWhereInput;
  OR?: TermSubscriptionWhereInput[] | TermSubscriptionWhereInput;
  NOT?: TermSubscriptionWhereInput[] | TermSubscriptionWhereInput;
}

export interface DepartmentUpdateManyMutationInput {
  name?: String;
}

export interface TermUpsertWithWhereUniqueWithoutVenuesInput {
  where: TermWhereUniqueInput;
  update: TermUpdateWithoutVenuesDataInput;
  create: TermCreateWithoutVenuesInput;
}

export interface SchoolUpdateManyMutationInput {
  longName?: String;
  shortName?: String;
}

export interface TermUpdateManyWithoutVenuesInput {
  create?: TermCreateWithoutVenuesInput[] | TermCreateWithoutVenuesInput;
  delete?: TermWhereUniqueInput[] | TermWhereUniqueInput;
  connect?: TermWhereUniqueInput[] | TermWhereUniqueInput;
  set?: TermWhereUniqueInput[] | TermWhereUniqueInput;
  disconnect?: TermWhereUniqueInput[] | TermWhereUniqueInput;
  update?:
    | TermUpdateWithWhereUniqueWithoutVenuesInput[]
    | TermUpdateWithWhereUniqueWithoutVenuesInput;
  upsert?:
    | TermUpsertWithWhereUniqueWithoutVenuesInput[]
    | TermUpsertWithWhereUniqueWithoutVenuesInput;
  deleteMany?: TermScalarWhereInput[] | TermScalarWhereInput;
  updateMany?: TermUpdateManyWithWhereNestedInput[] | TermUpdateManyWithWhereNestedInput;
}

export interface DepartmentUpdateManyDataInput {
  name?: String;
}

export type TermWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SchoolCreateInput {
  longName: String;
  shortName?: String;
  terms?: TermCreateManyWithoutSchoolInput;
  departments?: DepartmentCreateManyWithoutSchoolInput;
}

export type VenueWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DepartmentCreateManyWithoutSchoolInput {
  create?: DepartmentCreateWithoutSchoolInput[] | DepartmentCreateWithoutSchoolInput;
  connect?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
}

export interface TermCreateManyWithoutSchoolInput {
  create?: TermCreateWithoutSchoolInput[] | TermCreateWithoutSchoolInput;
  connect?: TermWhereUniqueInput[] | TermWhereUniqueInput;
}

export interface DepartmentCreateWithoutSchoolInput {
  name: String;
}

export interface VenueSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VenueWhereInput;
  AND?: VenueSubscriptionWhereInput[] | VenueSubscriptionWhereInput;
  OR?: VenueSubscriptionWhereInput[] | VenueSubscriptionWhereInput;
  NOT?: VenueSubscriptionWhereInput[] | VenueSubscriptionWhereInput;
}

export interface SchoolUpdateInput {
  longName?: String;
  shortName?: String;
  terms?: TermUpdateManyWithoutSchoolInput;
  departments?: DepartmentUpdateManyWithoutSchoolInput;
}

export interface TermUpdateWithWhereUniqueWithoutVenuesInput {
  where: TermWhereUniqueInput;
  data: TermUpdateWithoutVenuesDataInput;
}

export interface DepartmentUpdateManyWithoutSchoolInput {
  create?: DepartmentCreateWithoutSchoolInput[] | DepartmentCreateWithoutSchoolInput;
  delete?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
  connect?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
  set?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
  disconnect?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
  update?:
    | DepartmentUpdateWithWhereUniqueWithoutSchoolInput[]
    | DepartmentUpdateWithWhereUniqueWithoutSchoolInput;
  upsert?:
    | DepartmentUpsertWithWhereUniqueWithoutSchoolInput[]
    | DepartmentUpsertWithWhereUniqueWithoutSchoolInput;
  deleteMany?: DepartmentScalarWhereInput[] | DepartmentScalarWhereInput;
  updateMany?:
    | DepartmentUpdateManyWithWhereNestedInput[]
    | DepartmentUpdateManyWithWhereNestedInput;
}

export interface TermUpdateManyMutationInput {
  name?: String;
  startsAt?: DateTimeInput;
  endsAt?: DateTimeInput;
}

export interface DepartmentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: DepartmentScalarWhereInput[] | DepartmentScalarWhereInput;
  OR?: DepartmentScalarWhereInput[] | DepartmentScalarWhereInput;
  NOT?: DepartmentScalarWhereInput[] | DepartmentScalarWhereInput;
}

export interface DepartmentUpsertWithWhereUniqueWithoutSchoolInput {
  where: DepartmentWhereUniqueInput;
  update: DepartmentUpdateWithoutSchoolDataInput;
  create: DepartmentCreateWithoutSchoolInput;
}

export interface DepartmentUpdateWithoutSchoolDataInput {
  name?: String;
}

export interface DepartmentUpdateWithWhereUniqueWithoutSchoolInput {
  where: DepartmentWhereUniqueInput;
  data: DepartmentUpdateWithoutSchoolDataInput;
}

export interface SchoolUpdateOneRequiredWithoutTermsInput {
  create?: SchoolCreateWithoutTermsInput;
  update?: SchoolUpdateWithoutTermsDataInput;
  upsert?: SchoolUpsertWithoutTermsInput;
  connect?: SchoolWhereUniqueInput;
}

export interface TermCreateWithoutVenuesInput {
  name: String;
  startsAt: DateTimeInput;
  endsAt: DateTimeInput;
  school: SchoolCreateOneWithoutTermsInput;
}

export interface DepartmentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DepartmentWhereInput;
  AND?: DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput;
  OR?: DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput;
  NOT?: DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput;
}

export interface VenueCreateManyWithoutTermsInput {
  create?: VenueCreateWithoutTermsInput[] | VenueCreateWithoutTermsInput;
  connect?: VenueWhereUniqueInput[] | VenueWhereUniqueInput;
}

export interface SchoolCreateOneWithoutDepartmentsInput {
  create?: SchoolCreateWithoutDepartmentsInput;
  connect?: SchoolWhereUniqueInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface VenuePreviousValues {
  id: ID_Output;
  code: String;
  name: String;
  floor?: String;
  lat?: Float;
  lng?: Float;
  altitude?: Int;
}

export interface VenuePreviousValuesPromise extends Promise<VenuePreviousValues>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  floor: () => Promise<String>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  altitude: () => Promise<Int>;
}

export interface VenuePreviousValuesSubscription
  extends Promise<AsyncIterator<VenuePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  floor: () => Promise<AsyncIterator<String>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  altitude: () => Promise<AsyncIterator<Int>>;
}

export interface SchoolConnection {
  pageInfo: PageInfo;
  edges: SchoolEdge[];
}

export interface SchoolConnectionPromise extends Promise<SchoolConnection>, Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SchoolEdge>>() => T;
  aggregate: <T = AggregateSchoolPromise>() => T;
}

export interface SchoolConnectionSubscription
  extends Promise<AsyncIterator<SchoolConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SchoolEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSchoolSubscription>() => T;
}

export interface SchoolPreviousValues {
  id: ID_Output;
  longName: String;
  shortName?: String;
}

export interface SchoolPreviousValuesPromise extends Promise<SchoolPreviousValues>, Fragmentable {
  id: () => Promise<ID_Output>;
  longName: () => Promise<String>;
  shortName: () => Promise<String>;
}

export interface SchoolPreviousValuesSubscription
  extends Promise<AsyncIterator<SchoolPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  longName: () => Promise<AsyncIterator<String>>;
  shortName: () => Promise<AsyncIterator<String>>;
}

export interface TermSubscriptionPayload {
  mutation: MutationType;
  node: Term;
  updatedFields: String[];
  previousValues: TermPreviousValues;
}

export interface TermSubscriptionPayloadPromise
  extends Promise<TermSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TermPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TermPreviousValuesPromise>() => T;
}

export interface TermSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TermSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TermSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TermPreviousValuesSubscription>() => T;
}

export interface DepartmentEdge {
  node: Department;
  cursor: String;
}

export interface DepartmentEdgePromise extends Promise<DepartmentEdge>, Fragmentable {
  node: <T = DepartmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DepartmentEdgeSubscription
  extends Promise<AsyncIterator<DepartmentEdge>>,
    Fragmentable {
  node: <T = DepartmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDepartment {
  count: Int;
}

export interface AggregateDepartmentPromise extends Promise<AggregateDepartment>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDepartmentSubscription
  extends Promise<AsyncIterator<AggregateDepartment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Term {
  id: ID_Output;
  name: String;
  startsAt: DateTimeOutput;
  endsAt: DateTimeOutput;
}

export interface TermPromise extends Promise<Term>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  startsAt: () => Promise<DateTimeOutput>;
  endsAt: () => Promise<DateTimeOutput>;
  school: <T = SchoolPromise>() => T;
  venues: <T = FragmentableArray<Venue>>(args?: {
    where?: VenueWhereInput;
    orderBy?: VenueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TermSubscription extends Promise<AsyncIterator<Term>>, Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  startsAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endsAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  school: <T = SchoolSubscription>() => T;
  venues: <T = Promise<AsyncIterator<VenueSubscription>>>(args?: {
    where?: VenueWhereInput;
    orderBy?: VenueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise extends Promise<BatchPayload>, Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateVenue {
  count: Int;
}

export interface AggregateVenuePromise extends Promise<AggregateVenue>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVenueSubscription
  extends Promise<AsyncIterator<AggregateVenue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Venue {
  id: ID_Output;
  code: String;
  name: String;
  floor?: String;
  lat?: Float;
  lng?: Float;
  altitude?: Int;
}

export interface VenuePromise extends Promise<Venue>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  floor: () => Promise<String>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  altitude: () => Promise<Int>;
  terms: <T = FragmentableArray<Term>>(args?: {
    where?: TermWhereInput;
    orderBy?: TermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface VenueSubscription extends Promise<AsyncIterator<Venue>>, Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  floor: () => Promise<AsyncIterator<String>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  altitude: () => Promise<AsyncIterator<Int>>;
  terms: <T = Promise<AsyncIterator<TermSubscription>>>(args?: {
    where?: TermWhereInput;
    orderBy?: TermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface VenueConnection {
  pageInfo: PageInfo;
  edges: VenueEdge[];
}

export interface VenueConnectionPromise extends Promise<VenueConnection>, Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VenueEdge>>() => T;
  aggregate: <T = AggregateVenuePromise>() => T;
}

export interface VenueConnectionSubscription
  extends Promise<AsyncIterator<VenueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VenueEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVenueSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription extends Promise<AsyncIterator<PageInfo>>, Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface TermEdge {
  node: Term;
  cursor: String;
}

export interface TermEdgePromise extends Promise<TermEdge>, Fragmentable {
  node: <T = TermPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TermEdgeSubscription extends Promise<AsyncIterator<TermEdge>>, Fragmentable {
  node: <T = TermSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DepartmentConnection {
  pageInfo: PageInfo;
  edges: DepartmentEdge[];
}

export interface DepartmentConnectionPromise extends Promise<DepartmentConnection>, Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DepartmentEdge>>() => T;
  aggregate: <T = AggregateDepartmentPromise>() => T;
}

export interface DepartmentConnectionSubscription
  extends Promise<AsyncIterator<DepartmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DepartmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDepartmentSubscription>() => T;
}

export interface AggregateSchool {
  count: Int;
}

export interface AggregateSchoolPromise extends Promise<AggregateSchool>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSchoolSubscription
  extends Promise<AsyncIterator<AggregateSchool>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Department {
  id: ID_Output;
  name: String;
}

export interface DepartmentPromise extends Promise<Department>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  school: <T = SchoolPromise>() => T;
}

export interface DepartmentSubscription extends Promise<AsyncIterator<Department>>, Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  school: <T = SchoolSubscription>() => T;
}

export interface VenueSubscriptionPayload {
  mutation: MutationType;
  node: Venue;
  updatedFields: String[];
  previousValues: VenuePreviousValues;
}

export interface VenueSubscriptionPayloadPromise
  extends Promise<VenueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VenuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VenuePreviousValuesPromise>() => T;
}

export interface VenueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VenueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VenueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VenuePreviousValuesSubscription>() => T;
}

export interface VenueEdge {
  node: Venue;
  cursor: String;
}

export interface VenueEdgePromise extends Promise<VenueEdge>, Fragmentable {
  node: <T = VenuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface VenueEdgeSubscription extends Promise<AsyncIterator<VenueEdge>>, Fragmentable {
  node: <T = VenueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SchoolSubscriptionPayload {
  mutation: MutationType;
  node: School;
  updatedFields: String[];
  previousValues: SchoolPreviousValues;
}

export interface SchoolSubscriptionPayloadPromise
  extends Promise<SchoolSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SchoolPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SchoolPreviousValuesPromise>() => T;
}

export interface SchoolSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SchoolSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SchoolSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SchoolPreviousValuesSubscription>() => T;
}

export interface School {
  id: ID_Output;
  longName: String;
  shortName?: String;
}

export interface SchoolPromise extends Promise<School>, Fragmentable {
  id: () => Promise<ID_Output>;
  longName: () => Promise<String>;
  shortName: () => Promise<String>;
  terms: <T = FragmentableArray<Term>>(args?: {
    where?: TermWhereInput;
    orderBy?: TermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  departments: <T = FragmentableArray<Department>>(args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SchoolSubscription extends Promise<AsyncIterator<School>>, Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  longName: () => Promise<AsyncIterator<String>>;
  shortName: () => Promise<AsyncIterator<String>>;
  terms: <T = Promise<AsyncIterator<TermSubscription>>>(args?: {
    where?: TermWhereInput;
    orderBy?: TermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  departments: <T = Promise<AsyncIterator<DepartmentSubscription>>>(args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DepartmentPreviousValues {
  id: ID_Output;
  name: String;
}

export interface DepartmentPreviousValuesPromise
  extends Promise<DepartmentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface DepartmentPreviousValuesSubscription
  extends Promise<AsyncIterator<DepartmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface DepartmentSubscriptionPayload {
  mutation: MutationType;
  node: Department;
  updatedFields: String[];
  previousValues: DepartmentPreviousValues;
}

export interface DepartmentSubscriptionPayloadPromise
  extends Promise<DepartmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DepartmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DepartmentPreviousValuesPromise>() => T;
}

export interface DepartmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DepartmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DepartmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DepartmentPreviousValuesSubscription>() => T;
}

export interface AggregateTerm {
  count: Int;
}

export interface AggregateTermPromise extends Promise<AggregateTerm>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTermSubscription
  extends Promise<AsyncIterator<AggregateTerm>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TermPreviousValues {
  id: ID_Output;
  name: String;
  startsAt: DateTimeOutput;
  endsAt: DateTimeOutput;
}

export interface TermPreviousValuesPromise extends Promise<TermPreviousValues>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  startsAt: () => Promise<DateTimeOutput>;
  endsAt: () => Promise<DateTimeOutput>;
}

export interface TermPreviousValuesSubscription
  extends Promise<AsyncIterator<TermPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  startsAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endsAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SchoolEdge {
  node: School;
  cursor: String;
}

export interface SchoolEdgePromise extends Promise<SchoolEdge>, Fragmentable {
  node: <T = SchoolPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SchoolEdgeSubscription extends Promise<AsyncIterator<SchoolEdge>>, Fragmentable {
  node: <T = SchoolSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TermConnection {
  pageInfo: PageInfo;
  edges: TermEdge[];
}

export interface TermConnectionPromise extends Promise<TermConnection>, Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TermEdge>>() => T;
  aggregate: <T = AggregateTermPromise>() => T;
}

export interface TermConnectionSubscription
  extends Promise<AsyncIterator<TermConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TermEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTermSubscription>() => T;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: 'Department',
    embedded: false,
  },
  {
    name: 'School',
    embedded: false,
  },
  {
    name: 'Term',
    embedded: false,
  },
  {
    name: 'Venue',
    embedded: false,
  },
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`,
});
export const prisma = new Prisma();
